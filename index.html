<html>

<head>
    <link rel="stylesheet" href="./css/style.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script type="text/javascript" href="./illuminated.js-master/src/illuminated.js"></script>
</head>

<body onload="init();">
    <canvas id="canvas"></canvas>
</body>
<script type="text/javascript" src="libs/Box2D.js"></script>
<script type="text/javascript">
    var world;
    var debugDraw;
    var actualBody;
    var destroyThese = [];
    var objects = [];
    var oldWidth, oldHeight;
    var difference = 0.0;

        var b2Vec2 = Box2D.Common.Math.b2Vec2
            , b2BodyDef = Box2D.Dynamics.b2BodyDef
            , b2Body = Box2D.Dynamics.b2Body
            , b2FixtureDef = Box2D.Dynamics.b2FixtureDef
            , b2Fixture = Box2D.Dynamics.b2Fixture
            , b2World = Box2D.Dynamics.b2World
            , b2MassData = Box2D.Collision.Shapes.b2MassData
            , b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
            , b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
            , b2DebugDraw = Box2D.Dynamics.b2DebugDraw
            ;

    function init() {
        world = new b2World(
            new b2Vec2(0, 10)    //gravity
            , true                 //allow sleep
        );

        var bodyDef = new Box2D.Dynamics.b2BodyDef;

        var fixDef = new b2FixtureDef;
        //create some objects
        bodyDef.type = b2Body.b2_dynamicBody;
        for (var i = 0; i < 10; ++i) {
            if (Math.random() > 0.5) {
                fixDef.shape = new b2PolygonShape;
                fixDef.shape.SetAsBox(
                    Math.random() + 0.1 //half width
                    , Math.random() + 0.1 //half height
                );
            } else {
                fixDef.shape = new b2CircleShape(
                    Math.random() + 0.1 //radius
                );
            }
            bodyDef.position.x = Math.random() * 10;
            bodyDef.position.y = Math.random() * 10;
            var body = world.CreateBody(bodyDef);
            body.CreateFixture(fixDef);
            objects.push(body);
        }

        //setup debug draw
        debugDraw = new b2DebugDraw();
        debugDraw.SetSprite(document.getElementById("canvas").getContext("2d"));
        debugDraw.SetDrawScale(30.0);
        debugDraw.SetFillAlpha(0.3);
        debugDraw.SetLineThickness(1.0);
        debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
        world.SetDebugDraw(debugDraw);

        window.setInterval(update, 1000 / 60);

        resize();   
    };

    function update() {
        for(var d in destroyThese)
        {
            world.DestroyBody(destroyThese[d]);
        }
        if(difference != 0.0)
        {
            for(var o in objects)
            {
                oldX = objects[o].GetPosition().x;
                oldY = objects[o].GetPosition().y;
                objects[o].SetPosition(new b2Vec2(oldX, oldY-difference));
            }
            difference = 0.0;
        }
        destroyThese = [];
        world.Step(
            1 / 60   //frame-rate
            , 10       //velocity iterations
            , 10       //position iterations
        );
        world.DrawDebugData();
        world.ClearForces();
    };

    function createGround(x, y)
    {        
        if(actualBody != undefined)
        {
            destroyThese.push(actualBody);
        }
        var fixDef = new b2FixtureDef;
        fixDef.density = 1.0;
        fixDef.friction = 0.5;
        fixDef.restitution = 0.2;
        var fixBodyDef = new b2BodyDef;
        fixBodyDef.type = Box2D.Dynamics.b2Body.b2_staticBody;
        fixBodyDef.position.x = x/2;
        fixBodyDef.position.y = y;
        fixDef.shape = new b2PolygonShape;
        fixDef.shape.SetAsOrientedBox(x, 1, new b2Vec2(), .01);
        actualBody = world.CreateBody(fixBodyDef);
        actualBody.CreateFixture(fixDef);
    }

    function resize() {
        scale = debugDraw.GetDrawScale();

        // Our canvas must cover full height of screen
        // regardless of the resolution
        var height = window.innerHeight;

        // So we need to calculate the proper scaled width
        // that should work well with every resolution
        // var ratio = canvas.width/canvas.height;
        // var width = height * ratio;
        var width = window.innerWidth;

        canvas.width = width;
        canvas.height = height;

        if(oldWidth != undefined && oldHeight != undefined)
        {
            difference += (oldHeight - height) / scale;
        }

        oldWidth = width;
        oldHeight = height;

        // also dumy you gotta move the ground
        createGround(width / scale, height / scale);
    }

    window.addEventListener('resize', resize, false);

</script>

</html>